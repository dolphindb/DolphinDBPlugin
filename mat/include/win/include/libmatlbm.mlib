/*
 * Copyright 1984-2006 The MathWorks, Inc.
 * All Rights Reserved.
 */

target="C";
timestamp="Wed Feb 16 13:46:19 EST 2000";

_colonobj {         /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlf_colonobj;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

_get_ws_data {     /* m function name */
  nin     = 4;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlf_get_ws_data;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

_license_checkout { /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  varargout;        /* vargout used */
  mexonly;
  builtin;
  cname   = mlf_license_checkout;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* has side effects */
}

_system {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlf_system;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

_times_transpose {  /* m function name */
  nin    = 3;       /* number of M inputs */
  nout   = 1;       /* number of M outputs */
  scope  = global;
  builtin;
  cname  = mlf_times_transpose;   /* mxArray in and out */
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout used */
  reqin  = 3;       /* minimum number of inputs */
  reqout = 1;       /* minimum number of outputs */
}

abs {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfAbs;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

acos {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfAcos;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

acosh {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfAcosh;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

add_block {         /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfAdd_block;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 2;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

add_line {          /* m function name */
  nin     = 5;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfAdd_line;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 2;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

add_param {         /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  mexonly;
  cname   = mlfAdd_param;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 2;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

all {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfAll; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

and {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfAnd; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

any {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfAny; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

asin {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfAsin;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

asinh {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfAsinh;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

assignin {          /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfAssignin;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
  ws_interaction;
}

atan {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfAtan;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

atanh {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfAtanh;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

atan2 {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfAtan2;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

axes {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfAxes;  /* mxArray in and out */
  cname   = mlfNaxes;  /* used nargout */
  cname   = mlfVaxes;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

balance {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfBalance;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

beep {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfBeep;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

bitand {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfBitand;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

bitcmp {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfBitcmp;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

bitget {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfBitget;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

bitset {             /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfBitset;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

bitshift {             /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfBitshift;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

bitor {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfBitor;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

bitxor {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfBitxor;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

builtin {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  varargout;        /* vargout used */
  builtin;
  cname   = mlfBuiltin;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  ws_interaction;
  impure;
}

call_callback {     /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  hg_function;
  builtin;
  cname   = mlfCall_callback;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* has side effects */
}

callstats {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  varargout;        /* vargout used */
  mexonly;
  builtin;
  cname   = mlfCallstats;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* has side effects */
}

cat {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  intrinsic;
  cname   = mlfCat; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

cd {                /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfCd;  /* mxArray in and out */
  cname   = mlfNcd; /* used nargout */
  cname   = mlfVcd; /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* has side effects */
}

ceil {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfCeil;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

cell {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfCell;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

cell2struct {       /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfCell2struct;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

cellhorzcat {       /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  intrinsic;
  cname   = mlfCellhorzcat;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

cellvertcat {       /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  nolib;
  intrinsic;
  cname   = mlfCellvertcat;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

cells {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  nolib;
  cname   = mlfCells;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

char {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfChar;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

chdir {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfChdir;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* has side effects */
}

check_system {      /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  mexonly;
  cname   = mlfCheck_system;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* has side effects */
}

chol {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfChol;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

cholinc {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfCholinc;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

cholupdate {        /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfCholupdate;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

class {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfClassName;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

clc {             /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfClc;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure; /* ? */
}

clear {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  nolib;
  cname   = mlfClear;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  ws_interaction;
  impure;
}

clock {             /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfClock;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

close_system {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfClose_system;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

colon {             /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfColon;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

compare_system {    /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  mexonly;
  cname   = mlfCompare_system;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 3;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* has side effects */
}

complex {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfComplex;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

computer {             /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfComputer;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

conj {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfConj;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

conv2 {             /* m function name */
  nin     = 4;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfConv2;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

contourc {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfContourc;  /* mxArray in and out */
  cname   = mlfNcontourc;  /* used nargout */
  cname   = mlfVcontourc;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

copyobj {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfCopyobj;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

cos {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfCos; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

ctranspose {        /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfCtranspose;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

cosh {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfCosh;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

cumprod {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfCumprod;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

cumsum {            /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfCumsum;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

cputime {           /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfCputime;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

dbclear {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfDbclear;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

dbcont {            /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfDbcont;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

dbdown {            /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfDbdown;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

dbquit {            /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfDbquit;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

dbstack {           /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfDbstack;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

dbstatus {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfDbstatus;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

dbstep {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfDbstep;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

dbstop {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfDbstop;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

dbtype {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfDbtype;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

dbup {              /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfDbup;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

delete {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfDelete;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

delete_block {      /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfDelete_block;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

delete_line {       /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfDelete_line;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

delete_param {      /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  mexonly;
  cname   = mlfDelete_param;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 2;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

det {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfDet; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

diag {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfDiag;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

diary {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfDiary;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

diff {              /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfDiff;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

dir {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfDir; /* mxArray in and out */
  cname   = mlfNdir;/* used nargout */
  cname   = mlfVdir;/* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

disp {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfDisp;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

display {
  nin    = 1;       /* number of M inputs */
  nout   = 0;       /* number of M outputs */
  scope  = global;
  cname  = mlfPrintMatrix;   /* mxArray in and out */
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 0;       /* minimum number of outputs */
  /* ws_interaction; */
}

dongarra {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfDongarra;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

double {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfDouble;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

dos {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfDos; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

dragrect {          /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfDragrect;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

drawnow {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfDrawnow;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

echo {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfEcho;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

end {               /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfEnd; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

eig {               /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfEig; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

eps {               /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfEps; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

eq {                /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfEq;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

error {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;
  builtin;
  cname   = mlfError;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

errortrap {         /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfErrortrap;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

eval {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargout;        /* vargout used */
  builtin;
  cname   = mlfEval;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  ws_interaction;   /* has side effects */
}

evalc {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargout;        /* vargout used */
  builtin;
  mexonly;
  cname   = mlfEvalc;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  ws_interaction;   /* has side effects */
}

evalin {            /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargout;        /* vargout used */
  mexonly;
  builtin;
  cname   = mlfEvalin;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;   /* has side effects */
}

exist {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfExist;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;
}

exit {              /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfExit;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* runs finish.m */
}

exp {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfExp; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

eye {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfEye; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

false {             /* m function name */
  irname = "false_mxarray";
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfFalse;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

fclose {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFclose;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

feature {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFeature;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
  ws_interaction;
}

fieldnames {        /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFieldnames;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

fields {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  varargout;        /* vargout used */
  mexonly;
  builtin;
  cname   = mlfFields;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

feof {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFeof;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

ferror {            /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFerror;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

feval {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  varargout;        /* vargout used */
  builtin;
  cname   = mlfFeval;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
  ws_interaction;
}

fft {               /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFft; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

fftn {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFftn;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

fftw {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFftw;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

fgets {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFgets;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* has side effects */
}

figure {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfFigure;  /* mxArray in and out */
  cname   = mlfNfigure;  /* used nargout */
  cname   = mlfVfigure;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

fill {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfFill;  /* mxArray in and out */
  cname   = mlfNfill; /* used nargout */
  cname   = mlfVfill; /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

fill3 {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfFill3;  /* mxArray in and out */
  cname   = mlfNfill3;  /* used nargout */
  cname   = mlfVfill3;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

filter {            /* m function name */
  nin     = 5;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFilter;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

find {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFind;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

find_system {       /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfFind_system;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

findobj {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfFindobj;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

findpackage {       /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFindpackage;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

findstr {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFindstr;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

findtype {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFindtype;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

finite {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFinite;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

fix {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFix; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

floor {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFloor;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

format {            /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFormat;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

fopen {             /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFopen;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

fprintf {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfFprintf;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

frame2im {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfFrame2im;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

fread {             /* m function name */
  nin     = 4;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFread;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

fschange {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  varargout;        /* vargout used */
  mexonly;
  builtin;
  cname   = mlfFschange;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

fscanf {            /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFscanf;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

fseek {             /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFseek;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

ftell {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFtell;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

full {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFull; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

func2str {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFunc2str;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

functions {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfFunctions;  /* mxArray in and out */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

functionscalled {   /* m function name */
  nin     = 5;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfFunctionscalled;  /* mxArray in and out */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

fwrite {            /* m function name */
  nin     = 4;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfFwrite;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

gcbh {              /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfGcbh;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

ge {                /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfGe;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

get {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfGet; /* mxArray in and out */
  cname   = mlfNget;/* used nargout */
  cname   = mlfVget;/* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

getframe {          /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfGetframe; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

get_param {         /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfGet_param;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

getenv {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfGetenv;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

global {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  nolib;
  intrinsic;
  cname   = mlfGlobal;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  ws_interaction;
}

gt {                /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfGt;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

group {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;
  builtin;
  hg_function;
  cname   = mlfGroup;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

gs_get_buttonmotion {   /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfGs_get_buttonmotion;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

handle2struct {     /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfHandle2struct;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

handle {            /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfHandle;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

hardcopy {          /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfHardcopy;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

hcreate {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  varargout;        /* vargout used */
  mexonly;
  builtin;
  cname   = mlfHcreate;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

help {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfHelp;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

hittest {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfHittest;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

home {              /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfHome;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure; /* ? */
}

hess {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfHess;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

horzcat {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  intrinsic;
  cname   = mlfHorzcat;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

hregister {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfHregister;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

hypot {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfHypot;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

i {                 /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfI;   /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

j {                 /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfJ;   /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

_identity {         /* m function name */
  nin = 1;          /* number of M inputs */
  nout = 1;         /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

ifftn {
  nin    = 2;       /* number of M inputs */
  nout   = 1;       /* number of M outputs */
  scope  = global;
  builtin;
  cname  = mlfIfftn;   /* mxArray in and out */
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 1;       /* minimum number of outputs */
}

ifft {
  nin    = 3;       /* number of M inputs */
  nout   = 1;       /* number of M outputs */
  scope  = global;
  builtin;
  cname  = mlfIfft; /* mxArray in and out */
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 1;       /* minimum number of outputs */
}

im2frame {          /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfIm2frame;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

imag {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfImag;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

image {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfImage;  /* mxArray in and out */
  cname   = mlfNimage;  /* used nargout */
  cname   = mlfVimage;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

import {            /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfImport;  /* mxArray in and out */
  mexonly;
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

inf {               /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfInf;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

Inf {               /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfInf;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

inferiorto {        /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfInferiorto;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

inmem {             /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfInmem;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

input {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfInput;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* has side effects */
}

inputname {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfInputname;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;
}

int8 {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfInt8;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

int16 {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfInt16;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

int32 {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfInt32;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

int64 {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfInt64;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

inv {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfInv;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isa {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsa; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}


isequal {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfIsequal;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isequalwithequalnans { /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfIsequalwithequalnans;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isidentical {       /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfIsidentical;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isempty {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsempty;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isfinite {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsfinite;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isfloat {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsfloat;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isinteger {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsinteger;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

iscell {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIscell;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isstruct {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsstruct;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isglobal {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsglobal;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;
}

ishandle {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfIshandle;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;
}

isjava {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfIsjava;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

issparse {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIssparse;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

ischar {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIschar;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

islogical {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIslogical;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isscalar {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsscalar;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isvector {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsvector;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isstr {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsstr;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isstudent {         /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsstudent;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isinf {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsinf;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isletter {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsletter;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isnan {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsnan;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isnumeric {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsnumeric;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isreal {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsreal;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isruntime {         /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfIsruntime;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

isspace {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfIsspace;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

java {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  varargout;        /* vargout used */
  mexonly;
  builtin;
  cname   = mlfJava;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

/**************************************************/
/* java_method and java_object are here temporarily
 * in orded to break a job dependency.  They should
 * be removed once javaMethod and javaObject are in 
 * MATLAB in perfect BWB 5/5/00 */

java_array   {
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfJava_array;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

java_method {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfJava_method;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

java_object {       /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfJava_object;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}
/*************************************************/


javaArray {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfJavaArray;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

javaMethod {        /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfJavaMethod;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

javaObject {        /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfJavaObject;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

jit_bailout {
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfJitBailout;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

jit_breakpoint {
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfJitBreakpoint;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

keyboard {          /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfKeyboard;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

lastwarn {          /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfLastwarn;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

lasterr {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfLasterr;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

light {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfLight;  /* mxArray in and out */
  cname   = mlfNlight;  /* used nargout */
  cname   = mlfVlight;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

length {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfLength;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

ldivide {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfLdivide;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

le {                /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfLe;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

license {           /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfLicense;  /* mxArray in and out */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

line {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfLine;  /* mxArray in and out */
  cname   = mlfNline;  /* used nargout */
  cname   = mlfVline;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

load {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  nolib;
  cname   = mlfLoad;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;
}

load_ {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  nolib;
  cname   = mlfLoad_;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;
}

loadc_ {            /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  nolib;
  cname   = mlfLoadc_;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;
}

log {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfLog; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

log2 {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfLog2;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

logical {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfLogical;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

loglog {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfLoglog;  /* mxArray in and out */
  cname   = mlfNloglog;  /* used nargout */
  cname   = mlfVloglog;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

lookfor {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfLookfor;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

lower {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfLower;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

lt {                /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfLt;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

ltitr {             /* m function name */
  nin     = 4;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfLtitr;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

lu {                /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 4;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfLu;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

luinc {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfLuinc;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}


matlabpath {        /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  cname   = mlfMatlabpath;  /* mxArray in and out */
  varargin;
  varargout;
  builtin;
  mexonly;
  nargin  = 1;      /* nargin  not used */
  nargout = 1;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

matlabroot {        /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfMatlabroot;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

max {               /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfMax; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

mbchar {
  nin    = 1;       /* number of M inputs */
  nout   = 0;       /* number of M outputs */
  scope  = global;
  cname  = mlfMbchar;   /* mxArray in and out */
  builtin;
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 0;       /* minimum number of outputs */
}

mbint {
  nin    = 1;       /* number of M inputs */
  nout   = 0;       /* number of M outputs */
  scope  = global;
  cname  = mlfMbint;   /* mxArray in and out */
  builtin;
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 0;       /* minimum number of outputs */
}

mbreal {
  nin    = 1;       /* number of M inputs */
  nout   = 0;       /* number of M outputs */
  scope  = global;
  cname  = mlfMbreal;   /* mxArray in and out */
  builtin;
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 0;       /* minimum number of outputs */
}

mbscalar {
  nin    = 1;       /* number of M inputs */
  nout   = 0;       /* number of M outputs */
  scope  = global;
  cname  = mlfMbscalar;   /* mxArray in and out */
  builtin;
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 0;       /* minimum number of outputs */
}

mbvector {
  nin    = 1;       /* number of M inputs */
  nout   = 0;       /* number of M outputs */
  scope  = global;
  cname  = mlfMbvector;   /* mxArray in and out */
  builtin;
  nargin = 0;       /* nargin  not used */
  nargout= 0;       /* nargout not used */
  reqin  = 1;       /* minimum number of inputs */
  reqout = 0;       /* minimum number of outputs */
}

methods {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfMethods;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

mexext {            /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfMexext;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

mfilename {         /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfMfilename;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

mimofr {            /* m function name */
  nin     = 5;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfMimofr;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

min {               /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfMin; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

minus {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfMinus;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

mislocked {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfMislocked;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;
}

mlock {             /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfMlock;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  ws_interaction;
  impure;
}

mldivide {          /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfMldivide;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

mod {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfMod;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

mpower {            /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfMpower;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

mrdivide {          /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfMrdivide;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

mtimes {            /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfMtimes;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

more {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfMore;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

movie {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfMovie;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

munlock {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfMunlock;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  ws_interaction;
  impure;
}

namelengthmax {     /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfNamelengthmax;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

NaN {               /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfNan;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

nan {               /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfNan; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

nargin {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfNargin;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

nargout {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfNargout;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

ndims {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfNdims;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

ne {                /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfNe;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

neq {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfNeq;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

new_system {        /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfNew_system;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

norm {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfNorm;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

not {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfNot; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

numel {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfNumel;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

objectdirectory {   /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfObjectdirectory;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

ones {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfOnes;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

open_system {       /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfOpen_system;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

or {                /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfOr;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

pack {              /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfPack;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

patch {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfPatch;  /* mxArray in and out */
  cname   = mlfNpatch;  /* used nargout */
  cname   = mlfVpatch;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

pause {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfPause;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* may call into iqm */
}

persistent {        /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  nolib;
  intrinsic;
  cname   = mlfPersistent;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  ws_interaction;
}

pfile {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfPfile;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

permute {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfPermute;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

pi {                /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfPi;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

plot {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfPlot;  /* mxArray in and out */
  cname   = mlfNplot;  /* used nargout */
  cname   = mlfVplot;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

plot3 {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfPlot3;  /* mxArray in and out */
  cname   = mlfNplot3;  /* used nargout */
  cname   = mlfVplot3;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

plus {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfPlus;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

pow2 {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfPow2;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

prod {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfProd;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

power {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfPower;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

qr {                /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfQr;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

qrupdate {             /* m function name */
  nin     = 4;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfQrupdate;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

quit {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfQuit;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

qz {                /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 6;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfQz;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

rand {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfRand;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

randn {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfRandn;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

rbbox {             /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfRbbox;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

rcond {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfRcond;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

rdivide {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfRdivide;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

real {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfReal;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

reallog {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfReallog;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

realpow {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfRealpow;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

realsqrt {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfRealsqrt;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

rectangle {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfRectangle;  /* mxArray in and out */
  cname   = mlfNrectangle;  /* used nargout */
  cname   = mlfVrectangle;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

repaint_figure {    /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfRepaint_figure;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

resize_figure {     /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfResize_figure;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

regexp {            /* m function name */
  nin     = 4;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfRegexp;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 2;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;   /* has side effects */
}

regexpi {           /* m function name */
  nin     = 4;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfRegexpi;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 2;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;   /* has side effects */
}

regexprep {         /* m function name */
  nin     = 6;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfRegexprep;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 3;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;   /* has side effects */
}

rehash {           /* m function name */
  nin     = 1;     /* number of M inputs */
  nout    = 0;     /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfRehash;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

rem {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfRem;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

reset {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfReset;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

reshape {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfReshape;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

rethrow {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfRethrow;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

rmappdata {         /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfRmappdata;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 2;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

round {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfRound;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

rtwgen {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfRtwgen; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

runtime {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfRuntime;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

save {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  nolib;
  cname   = mlfSave;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  ws_interaction;
}

save_system {       /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  mexonly;
  cname   = mlfSave_system;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

schur {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSchur;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* uses mexCallMATLAB */      
}

selectmoveresize {  /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfSelectmoveresize;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

semilogx {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfSemilogx;  /* mxArray in and out */
  cname   = mlfNsemilogx;  /* used nargout */
  cname   = mlfVsemilogx;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

semilogy {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfSemilogy;  /* mxArray in and out */
  cname   = mlfNsemilogy;  /* used nargout */
  cname   = mlfVsemilogy;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

set {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfSet;  /* mxArray in and out */
  cname   = mlfNset;  /* used nargout */
  cname   = mlfVset;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

setappdata {        /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfSetappdata;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

set_param {         /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfSet_param;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 3;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

setstr {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSetstr;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

sign {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSign;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

sim {               /* m function name */
  nin     = 4;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfSim; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

simulink {          /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfSimulink; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

simver {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfSimver; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

sin {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSin; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

single {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSingle;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

sinh {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSinh;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

size {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargout;        /* vargout used */
  builtin;
  cname   = mlfSize;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

sldebug {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfSldebug;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

sort {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSort;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

sparse {            /* m function name */
  nin     = 6;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSparse;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

sparsfun {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 5;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfSparsfun;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

sprintf {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfSprintf;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

sqrt {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSqrt;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

sscanf {            /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 4;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSscanf;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

str2func {          /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfStr2func;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* may cause schemas to be run */
}

strfind {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfStrfind;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

string {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  nolib;
  cname   = mlfString;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

strrep {            /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfStrrep;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

strcmp {            /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfStrcmp;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

strcmpi {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfStrcmpi;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

strncmp {           /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfStrncmp;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

strncmpi {          /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfStrncmpi;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

struct {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfStruct;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

struct2cell {       /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfStruct2cell;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

struct2handle {     /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfStruct2handle;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

subsasgn {          /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSubsasgn;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  ws_interaction;
}

subsindex {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSubsindex;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

subsref {           /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  varargout;
  cname   = mlfSubsref;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

sum {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSum; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

superiorto {        /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfSuperiorto;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

surface {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfSurface;  /* mxArray in and out */
  cname   = mlfNsurface;  /* used nargout */
  cname   = mlfVsurface;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

svd {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfSvd; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

system {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfSystem;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* has side effects */
}

system_dependent {  /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfSystem_dependent;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
  ws_interaction;
}

tan {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfTan;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

tanh {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfTanh;/* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

text {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;          /* vargin used */
  builtin;
  hg_function;
  cname   = mlfText;  /* mxArray in and out */
  cname   = mlfNtext;  /* used nargout */
  cname   = mlfVtext;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

tic {               /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfTic; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;          /* has side effects */
}

times {             /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfTimes;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

toc {               /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfToc; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;           /* has side effects */
}

transpose {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfTranspose;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

trmginput {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  varargout;        /* vargout used */
  mexonly;
  builtin;
  cname   = mlfTrmginput;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

tril {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfTril;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

triu {              /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfTriu;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

true {              /* m function name */
  irname = "true_mxarray";
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname = mlfTrue;
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

type {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfType;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

u_convert_to_gobject {  /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  hg_function;
  cname   = mlfU_convert_to_gobject;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

uicontrol {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfUicontrol;  /* mxArray in and out */
  cname   = mlfNuicontrol;  /* used nargout */
  cname   = mlfVuicontrol;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

uicontextmenu {     /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfUicontextmenu;  /* mxArray in and out */
  cname   = mlfNuicontextmenu;  /* used nargout */
  cname   = mlfVuicontextmenu;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

uigetdir {          /* m function name */
  nin     = 4;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfUigetdir;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

uigetfile {         /* m function name */
  nin     = 4;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfUigetfile;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

uiputfile {         /* m function name */
  nin     = 4;      /* number of M inputs */
  nout    = 3;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfUiputfile;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

uisetcolor {        /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfUisetcolor;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

uisetfont {         /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfUisetfont;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

uimenu {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfUimenu;  /* mxArray in and out */
  cname   = mlfNuimenu;  /* used nargout */
  cname   = mlfVuimenu;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

uimenufcn {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfUimenufcn;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

uint8 {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfUint8;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

uint16 {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfUint16;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

uint32 {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfUint32;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

uint64 {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfUint64;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

uipushtool {        /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfUipushtool;  /* mxArray in and out */
  cname   = mlfNuipushtool;  /* used nargout */
  cname   = mlfVuipushtool;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

uitoggletool {      /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfUitoggletool;  /* mxArray in and out */
  cname   = mlfNuitoggletool;  /* used nargout */
  cname   = mlfVuitoggletool;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

uitoolbar {         /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  hg_function;
  cname   = mlfUitoolbar;  /* mxArray in and out */
  cname   = mlfNuitoolbar;  /* used nargout */
  cname   = mlfVuitoolbar;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

uminus {            /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfUminus;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

uplus {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfUplus;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

upper {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfUpper;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

unix {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfUnix;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;           /* has side effects */
}

version {           /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  builtin;
  cname   = mlfVersion;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

vertcat {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  intrinsic;
  cname   = mlfVertcat;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

waitfor {           /* m function name */
  nin     = 3;      /* number of M inputs */
  nout    = 0;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfWaitfor;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
  impure;
}

waitforbuttonpress {             /* m function name */
  nin     = 0;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  hg_function;
  cname   = mlfWaitforbuttonpress;  /* mxArray in and out */
  cname   = mlfNwaitforbuttonpress;  /* used nargout */
  cname   = mlfVwaitforbuttonpress;  /* output ignored */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  impure;
}

warning {           /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 2;      /* number of M outputs */
  scope   = global;
  varargin;
  builtin;
  cname   = mlfWarning;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 1;      /* nargout used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 0;      /* minimum number of outputs */
}

which {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfWhich;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

who {               /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfWho; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;
}

whos {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  mexonly;
  builtin;
  cname   = mlfWhos;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
  ws_interaction;
}

what {              /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  mexonly;
  builtin;
  cname   = mlfWhat;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

xlate {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  varargout;        /* vargout used */
  builtin;
  cname   = mlfXlate;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 1;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

xor {               /* m function name */
  nin     = 2;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  builtin;
  intrinsic;
  cname   = mlfXor; /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}

zeros {             /* m function name */
  nin     = 1;      /* number of M inputs */
  nout    = 1;      /* number of M outputs */
  scope   = global;
  varargin;         /* vargin used */
  builtin;
  cname   = mlfZeros;  /* mxArray in and out */
  nargin  = 0;      /* nargin  not used */
  nargout = 0;      /* nargout not used */
  reqin   = 0;      /* minimum number of inputs */
  reqout  = 1;      /* minimum number of outputs */
}
